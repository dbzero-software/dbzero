#pragma once

#include <cstddef>
#include <Python.h>
#include "PyWrapper.hpp"
#include <atomic>
#include "shared_py_object.hpp"

namespace db0::object_model

{
    
    class Object; 
    
}

namespace db0::python

{
    
    // check for a memo type (i.e. generated by wrapPyClass)
    bool PyMemo_Check(PyObject *obj);
    bool PyMemoType_Check(PyTypeObject *type);
    
    class MemoTypeDecoration
    {   
    public:     
        MemoTypeDecoration(const char *prefix_name, const char *type_id, const char *file_name);

        // get decoration of a given memo type
        static inline MemoTypeDecoration &get(PyTypeObject *type)
        {
            assert(PyMemoType_Check(type) && "Invalid type (expected memo type)");
            return *reinterpret_cast<MemoTypeDecoration*>((char*)type + sizeof(PyHeapTypeObject));    
        }
        
        // @return nullptr if no file name is set
        inline const char *tryGetFileName() const {
            return m_file_name;
        }

        // @return nullptr if no prefix name is set
        inline const char *tryGetPrefixName() const {
            return m_prefix_name_ptr;
        }

        // @return nullptr if no type id is set
        inline const char *tryGetTypeId() const {
            return m_type_id;
        }

        // @return empty string if no prefix name is set
        const char *getPrefixName() const;

        std::uint64_t getFixtureUUID();
        
        void close();

    private:
        const char *m_prefix_name_ptr = 0;
        const char *m_type_id = 0;
        const char *m_file_name = 0;
        // resolved fixture UUID (initialized by the process)
        std::atomic<std::uint64_t> m_fixture_uuid = 0;        
    };
    
    using MemoObject = PyWrapper<db0::object_model::Object>;
    
    PyTypeObject *wrapPyType(PyTypeObject *, bool is_singleton, const char *prefix_name, const char *type_id);
    PyObject *wrapPyClass(PyObject *self, PyObject *, PyObject *kwargs);
    
    MemoObject *PyAPI_MemoObject_new(PyTypeObject *type, PyObject * = nullptr, PyObject * = nullptr);
    // create a memo object stub
    shared_py_object<MemoObject*> MemoObjectStub_new(PyTypeObject *type);
    PyObject *MemoObject_alloc(PyTypeObject *type, Py_ssize_t nitems);
    
    void MemoObject_del(MemoObject* self);
    void MemoObject_drop(MemoObject* self);
    int PyAPI_MemoObject_init(MemoObject* self, PyObject* args, PyObject* kwds);
    PyObject *MemoObject_getattro(MemoObject *self, PyObject *attr);
    int MemoObject_setattro(MemoObject *self, PyObject *attr, PyObject *value);
    // check for equal instances - i.e. if fixture and address are the same
    bool isEqual(MemoObject *, MemoObject *);
        
    // check if memo type has been marked as singleton
    bool PyMemoType_IsSingleton(PyTypeObject *type);
    
    PyObject *MemoObject_GetFieldLayout(MemoObject *);
    
    PyObject *MemoObject_DescribeObject(MemoObject *);
    PyObject *PyAPI_MemoObject_IsTag(PyObject *self, PyObject *const *args, Py_ssize_t nargs);
    PyObject *MemoObject_str(MemoObject *);
    
    void MemoType_get_info(PyTypeObject *type, PyObject *dict);
    void MemoType_close(PyTypeObject *type);
    
    PyObject *MemoObject_set_prefix(MemoObject *, const char *prefix_name);
    
    PyObject *tryGetAttributes(PyTypeObject *type);
    // Try retrieving a memo member cast to a specific type
    // type ignored for non-memo members
    PyObject *tryGetAttrAs(MemoObject *, PyObject *attr, PyTypeObject *);
    
}