#pragma once

#include <cstddef>
#include <Python.h>
#include "PyWrapper.hpp"
#include <atomic>
#include "shared_py_object.hpp"
#include <dbzero/core/memory/AccessOptions.hpp>

namespace db0::object_model

{
    
    class Object;
    
}

namespace db0::python

{
    
    // check for a memo type (i.e. generated by wrapPyClass)
    bool PyMemo_Check(PyObject *obj);
    bool PyMemoType_Check(PyTypeObject *type);
    using AccessType = db0::AccessType;

    class MemoTypeDecoration
    {   
    public:     
        MemoTypeDecoration(const char *prefix_name, const char *type_id, const char *file_name,
            std::vector<std::string> &&init_vars);
        
        // get decoration of a given memo type
        static inline MemoTypeDecoration &get(PyTypeObject *type)
        {
            assert(PyMemoType_Check(type) && "Invalid type (expected memo type)");
            return *reinterpret_cast<MemoTypeDecoration*>((char*)type + sizeof(PyHeapTypeObject));    
        }
        
        // @return nullptr if no file name is set
        inline const char *tryGetFileName() const {
            return m_file_name;
        }

        // @return nullptr if no prefix name is set
        inline const char *tryGetPrefixName() const {
            return m_prefix_name_ptr;
        }

        // @return nullptr if no type id is set
        inline const char *tryGetTypeId() const {
            return m_type_id;
        }

        // @return empty string if no prefix name is set
        const char *getPrefixName() const;
        // @return variables potentially asignable during the type initialization
        const std::vector<std::string> &getInitVars() const;
        
        // @param access_type to use for opening the prefix if UUID needs to be resolved by name
        // note that read-only access cannot later be upgraded to read-write
        std::uint64_t getFixtureUUID(AccessType access_type = AccessType::READ_WRITE);
        
        void close();

    private:
        const char *m_prefix_name_ptr = 0;
        const char *m_type_id = 0;
        const char *m_file_name = 0;
        // variables potentially asignable during the type initialization
        const std::vector<std::string> m_init_vars;
        // resolved fixture UUID (initialized by the process)
        std::atomic<std::uint64_t> m_fixture_uuid = 0;      
    };
    
    using MemoObject = PyWrapper<db0::object_model::Object>;
        
    PyObject *wrapPyClass(PyObject *self, PyObject *, PyObject *kwargs);
    
    MemoObject *PyAPI_MemoObject_new(PyTypeObject *type, PyObject * = nullptr, PyObject * = nullptr);
    // create a memo object stub
    shared_py_object<MemoObject*> MemoObjectStub_new(PyTypeObject *type);
    PyObject *MemoObject_alloc(PyTypeObject *type, Py_ssize_t nitems);
    
    void MemoObject_del(MemoObject* self);
    void MemoObject_drop(MemoObject* self);
    int PyAPI_MemoObject_init(MemoObject* self, PyObject* args, PyObject* kwds);
    PyObject *MemoObject_getattro(MemoObject *self, PyObject *attr);
    int MemoObject_setattro(MemoObject *self, PyObject *attr, PyObject *value);
    // check for equal instances - i.e. if fixture and address are the same
    bool isEqual(MemoObject *, MemoObject *);
        
    // check if memo type has been marked as singleton
    bool PyMemoType_IsSingleton(PyTypeObject *type);
    
    PyObject *MemoObject_GetFieldLayout(MemoObject *);
    
    PyObject *MemoObject_DescribeObject(MemoObject *);
    PyObject *MemoObject_str(MemoObject *);
    
    void MemoType_get_info(PyTypeObject *type, PyObject *dict);
    void MemoType_close(PyTypeObject *type);
    
    PyObject *MemoObject_set_prefix(MemoObject *, const char *prefix_name);
    
    PyObject *tryGetAttributes(PyTypeObject *type);
    // Try retrieving a memo member cast to a specific type
    // type ignored for non-memo members
    PyObject *tryGetAttrAs(MemoObject *, PyObject *attr, PyTypeObject *);
    
    PyObject *tryLoadMemo(MemoObject *memo_obj, PyObject* kwargs,  PyObject* exclude);
}